<!doctype html>
<html lang="id">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Face Recognition (OpenCV.js WebAssembly + Benchmark)</title>
<style>
  :root{
    --bg:#0f1720;
    --panel:#0b1220;
    --text:#e6eef6;
    --muted:#8fa4bf;
    --btn:#2b6cb0;
    --btn2:#334155;
    --border:#1b2b48;
  }
  *{box-sizing:border-box}
  body{
    margin:16px;
    background:var(--bg);
    color:var(--text);
    font:14px/1.55 system-ui,Segoe UI,Roboto,Arial;
  }
  .card{
    max-width:1000px;
    margin:auto;
    background:var(--panel);
    border:1px solid var(--border);
    border-radius:14px;
    padding:16px;
    box-shadow:0 10px 24px rgba(0,0,0,.5);
  }
  h2{margin:0 0 10px}
  .muted{color:var(--muted)}
  label{display:block;margin:.5rem 0 .2rem;color:#9fb0c9}
  input,select,textarea{
    width:100%;
    padding:8px;
    border-radius:8px;
    border:1px solid #20314a;
    background:#071623;
    color:#dfeefc;
    font:13px system-ui,Segoe UI,Roboto,Arial;
  }
  textarea{resize:vertical;min-height:80px}
  button{
    padding:8px 12px;
    border:0;
    border-radius:10px;
    background:var(--btn);
    color:#fff;
    cursor:pointer;
  }
  button.secondary{background:var(--btn2)}
  button:disabled{opacity:.6;cursor:not-allowed}
  .grid{
    display:grid;
    grid-template-columns:1fr 140px 140px 220px;
    gap:10px;
  }
  .row{
    display:flex;
    gap:8px;
    flex-wrap:wrap;
    align-items:end;
  }
  #canvas{
    width:100%;
    max-width:1000px;
    border-radius:10px;
    background:#000;
    display:block;
  }
  #video{
    width:100%;
    max-width:1000px;
    border-radius:10px;
    margin:8px 0;
    display:none;
    opacity:.7;
  }
  .pill{
    display:inline-block;
    padding:4px 8px;
    border-radius:999px;
    background:#1a2a44;
    margin-left:6px;
    font-size:12px;
  }
  pre{white-space:pre-wrap}
  #benchSvg{
    width:100%;
    height:160px;
    background:#020617;
    border-radius:10px;
    margin-top:6px;
  }
</style>
</head>
<body>
  <div class="card">
    <h2>
      Face Recognition — WebAssembly
      <span class="pill">OpenCV.js 4.x (WASM)</span>
      <span class="pill">Cascade + LBP + Cosine</span>
      <span class="pill">Log 50 frame</span>
      <span class="pill">Stop on Verified</span>
    </h2>

    <div class="grid">
      <div>
        <label>Pilih kamera</label>
        <select id="camera"></select>
        <div class="muted" style="font-size:12px">
          Jika kosong: klik Start lalu izinkan kamera.
        </div>
      </div>
      <div>
        <label>Ukuran canvas</label>
        <select id="size">
          <option value="320x240">320×240</option>
          <option value="480x360">480×360</option>
          <option value="640x480" selected>640×480</option>
        </select>
      </div>
      <div>
        <label>Process every N frames</label>
        <select id="nth">
          <option value="1">N=1</option>
          <option value="2" selected>N=2</option>
          <option value="3">N=3</option>
          <option value="4">N=4</option>
        </select>
      </div>
      <div class="row">
        <button id="start" disabled>Start</button>
        <button id="stop" class="secondary" disabled>Stop</button>
        <label style="display:flex;gap:6px;align-items:center;color:#9fb0c9">
          <input type="checkbox" id="showVideo"> preview video
        </label>
      </div>
    </div>

    <div class="row" style="margin-top:10px">
      <div>
        <label>Nama untuk enroll</label>
        <input id="name" placeholder="mis: Sismadi">
      </div>
      <div>
        <label>Sample</label>
        <select id="samples">
          <option>10</option>
          <option>15</option>
          <option selected>20</option>
          <option>30</option>
        </select>
      </div>
      <div>
        <label>Threshold cosine</label>
        <input id="th" value="0.90">
      </div>
      <div class="row">
        <button id="enroll" class="secondary" disabled>Enroll</button>
        <button id="clearDb" class="secondary">Clear DB</button>
        <button id="exportDb" class="secondary">Export</button>
        <label class="secondary" style="padding:8px 12px;border-radius:10px;cursor:pointer;display:inline-flex;align-items:center;gap:6px;background:#334155">
          Import
          <input id="importDb" type="file" accept="application/json" style="display:none">
        </label>
      </div>
    </div>

    <p class="muted" id="status">
      Status: memuat OpenCV.js (WebAssembly)…
    </p>
    <video id="video" playsinline autoplay muted></video>
    <canvas id="canvas" width="640" height="480"></canvas>

    <div style="margin-top:12px">
      <label>Benchmark log (ms per processed frame) — maksimal 50 data (index,ms)</label>
      <textarea id="bench"></textarea>
      <div class="row" style="margin-top:6px;align-items:center">
        <span id="benchInfo" class="muted" style="flex:1 1 auto;font-size:12px">
          Belum ada data benchmark.
        </span>
        <button id="renderChart" class="secondary">Render Chart</button>
        <button id="clearBench" class="secondary">Clear Log</button>
      </div>
      <svg id="benchSvg"></svg>
    </div>

    <p class="muted" style="margin-top:8px">
      Versi ini identik dengan baseline (OpenCV.js 3.4 asm.js), hanya berbeda
      pada backend WebAssembly. Pipeline: Haar cascade → wajah terbesar →
      LBP 100×100 → cosine similarity. Jika score ≥ threshold, pemindaian
      dihentikan dan log ditulis ke console + panel log. Benchmark & chart
      menampilkan 50 frame terakhir secara real-time.
    </p>
    <pre id="log" class="muted"></pre>
  </div>

  <!-- OpenCV.js 4.x: build WebAssembly -->
  <script async src="https://docs.opencv.org/4.x/opencv.js"
          onload="onOpenCvReady()"></script>

  <script>
  // ===== DOM refs & util UI =====
  const $ = (id)=>document.getElementById(id);
  const camSel    = $("camera");
  const nthEl     = $("nth");
  const sizeEl    = $("size");
  const btnS      = $("start");
  const btnT      = $("stop");
  const showVideoCb = $("showVideo");

  const nameEl    = $("name");
  const samplesEl = $("samples");
  const thEl      = $("th");
  const btnEnroll = $("enroll");
  const btnClear  = $("clearDb");
  const btnExport = $("exportDb");
  const inImport  = $("importDb");

  const statusEl = $("status");
  const logEl    = $("log");
  const video    = $("video");
  const canvas   = $("canvas");
  const ctx      = canvas.getContext('2d');

  // Benchmark DOM
  const benchEl       = $("bench");
  const benchInfoEl   = $("benchInfo");
  const benchSvg      = $("benchSvg");
  const btnRenderChart= $("renderChart");
  const btnClearBench = $("clearBench");

  const log = (...a)=>{
    console.log(...a);
    logEl.textContent = a.join(" ")+"\n"+logEl.textContent.slice(0,2000);
  };

  // ===== RECOGNITION core (LBP + cosine) =====
  let stream=null, running=false, rafId=null;
  let enrolling=false, enrollLeft=0, enrollSum=null;
  let detectEveryN=2, frameIndex=0, facesCount=0;
  let procFPS=0, lastFPS=0, procCount=0;
  let classifier=null, gray=null, rgba=null;

  const cascadeURL='https://raw.githubusercontent.com/opencv/opencv/master/data/haarcascades/haarcascade_frontalface_alt2.xml';

  const DB_KEY='face_db';
  const LBP_SIZE=100;

  function loadDB(){
    try{
      return JSON.parse(localStorage.getItem(DB_KEY) || '{"labels":[]}');
    }catch(e){
      return {labels:[]};
    }
  }
  function saveDB(db){ localStorage.setItem(DB_KEY, JSON.stringify(db)); }
  function clearDB(){ localStorage.removeItem(DB_KEY); }

  function bestMatch(vec, db){
    if(!db.labels.length) return {name:"Unknown", score:0};
    let best={name:"Unknown",score:0};
    for(const r of db.labels){
      const s = cosine(vec, r.vec);
      if(s > best.score) best = {name:r.name,score:s};
    }
    return best;
  }

  function lbpHistFromBytes(bytes,w,h){
    const hist = new Float32Array(256);
    for(let y=1;y<h-1;y++){
      const yp=y*w;
      for(let x=1;x<w-1;x++){
        const c = bytes[yp+x];
        const code =
          ((bytes[(y-1)*w+(x-1)]>=c)<<7)|
          ((bytes[(y-1)*w+(x  )]>=c)<<6)|
          ((bytes[(y-1)*w+(x+1)]>=c)<<5)|
          ((bytes[(y  )*w+(x+1)]>=c)<<4)|
          ((bytes[(y+1)*w+(x+1)]>=c)<<3)|
          ((bytes[(y+1)*w+(x  )]>=c)<<2)|
          ((bytes[(y+1)*w+(x-1)]>=c)<<1)|
          ((bytes[(y  )*w+(x-1)]>=c)<<0);
        hist[code]+=1;
      }
    }
    let norm=0;
    for(let i=0;i<256;i++) norm+=hist[i]*hist[i];
    norm=Math.sqrt(norm)||1;
    for(let i=0;i<256;i++) hist[i]/=norm;
    return hist;
  }

  function addInPlace(a,b){
    for(let i=0;i<a.length;i++) a[i]+=b[i];
  }
  function scaleInPlace(a,s){
    for(let i=0;i<a.length;i++) a[i]*=s;
  }
  function cosine(a,b){
    let dot=0,na=0,nb=0;
    for(let i=0;i<a.length;i++){
      dot+=a[i]*b[i];
      na+=a[i]*a[i];
      nb+=b[i]*b[i];
    }
    return dot/(Math.sqrt(na)*Math.sqrt(nb)+1e-9);
  }

  // ===== Benchmark data & helpers =====
  const benchData = []; // dt per processed frame (ms)
  const MAX_BENCH = 50;

  function benchAdd(dt){
    benchData.push(dt);
    if(benchData.length>MAX_BENCH) benchData.shift();
    updateBenchText();
    renderBenchChart(); // realtime
  }

  function updateBenchText(){
    if(!benchData.length){
      benchEl.value = "";
      benchInfoEl.textContent = "Belum ada data benchmark.";
      return;
    }
    const n = benchData.length;
    let sum=0, min=benchData[0], max=benchData[0];
    for(let i=0;i<n;i++){
      const v=benchData[i];
      sum+=v;
      if(v<min) min=v;
      if(v>max) max=v;
    }
    const avg = sum/n;
    benchEl.value = benchData.map((v,i)=>`${i+1},${v.toFixed(2)}`).join("\n");
    benchInfoEl.textContent =
      `samples: ${n} (maks ${MAX_BENCH}), avg: ${avg.toFixed(2)} ms, `+
      `min: ${min.toFixed(2)} ms, max: ${max.toFixed(2)} ms`;
  }

  function renderBenchChart(){
    const svg = benchSvg;
    const ns = "http://www.w3.org/2000/svg";
    while(svg.firstChild) svg.removeChild(svg.firstChild);
    if(!benchData.length) return;

    const w = svg.clientWidth || 800;
    const h = svg.clientHeight || 160;
    const n = benchData.length;
    const max = Math.max(...benchData);

    const paddingLeft = 30;
    const paddingBottom = 18;
    const usableW = w - paddingLeft - 4;
    const usableH = h - paddingBottom - 4;
    const barW = Math.max(1, usableW / n);

    const bg = document.createElementNS(ns,"rect");
    bg.setAttribute("x",0);
    bg.setAttribute("y",0);
    bg.setAttribute("width",w);
    bg.setAttribute("height",h);
    bg.setAttribute("fill","#020617");
    svg.appendChild(bg);

    for(let i=0;i<n;i++){
      const v = benchData[i];
      const bh = (v/max)*usableH;
      const rect = document.createElementNS(ns,"rect");
      rect.setAttribute("x", paddingLeft + i*barW);
      rect.setAttribute("y", h - paddingBottom - bh);
      rect.setAttribute("width", Math.max(1, barW*0.9));
      rect.setAttribute("height", bh);
      rect.setAttribute("fill", "#38bdf8");
      svg.appendChild(rect);
    }

    const axis = document.createElementNS(ns,"line");
    axis.setAttribute("x1", paddingLeft);
    axis.setAttribute("y1", 4);
    axis.setAttribute("x2", paddingLeft);
    axis.setAttribute("y2", h - paddingBottom);
    axis.setAttribute("stroke","#64748b");
    axis.setAttribute("stroke-width","1");
    svg.appendChild(axis);

    const axisX = document.createElementNS(ns,"line");
    axisX.setAttribute("x1", paddingLeft);
    axisX.setAttribute("y1", h - paddingBottom);
    axisX.setAttribute("x2", w - 4);
    axisX.setAttribute("y2", h - paddingBottom);
    axisX.setAttribute("stroke","#64748b");
    axisX.setAttribute("stroke-width","1");
    svg.appendChild(axisX);

    const textMax = document.createElementNS(ns,"text");
    textMax.textContent = `${max.toFixed(1)} ms`;
    textMax.setAttribute("x",4);
    textMax.setAttribute("y",12);
    textMax.setAttribute("fill","#94a3b8");
    textMax.setAttribute("font-size","10");
    svg.appendChild(textMax);

    const textZero = document.createElementNS(ns,"text");
    textZero.textContent = "0";
    textZero.setAttribute("x",8);
    textZero.setAttribute("y",h - paddingBottom);
    textZero.setAttribute("fill","#94a3b8");
    textZero.setAttribute("font-size","10");
    svg.appendChild(textZero);

    const title = document.createElementNS(ns,"text");
    title.textContent = "Benchmark: ms per processed frame (WASM OpenCV, 50 terbaru)";
    title.setAttribute("x",paddingLeft+4);
    title.setAttribute("y",14);
    title.setAttribute("fill","#e5e7eb");
    title.setAttribute("font-size","11");
    svg.appendChild(title);
  }

  btnRenderChart.onclick = renderBenchChart;
  btnClearBench.onclick = ()=>{
    benchData.length = 0;
    updateBenchText();
    while(benchSvg.firstChild) benchSvg.removeChild(benchSvg.firstChild);
  };

  // ===== OpenCV init (WebAssembly) =====
  function onOpenCvReady(){
    if(window.cv && cv.getBuildInformation){
      initOpenCV();
    }else if(window.cv){
      cv['onRuntimeInitialized'] = initOpenCV;
    }
  }

  async function initOpenCV(){
    try{
      statusEl.textContent='Status: memuat cascade (WASM)…';
      const res = await fetch(cascadeURL);
      const buf = new Uint8Array(await res.arrayBuffer());
      cv.FS_createDataFile('/', 'haarcascade.xml', buf, true, false, false);

      classifier = new cv.CascadeClassifier();
      classifier.load('haarcascade.xml');

      statusEl.textContent='Status: OpenCV WebAssembly siap. Klik Start.';
      btnS.disabled=false;
      btnEnroll.disabled=false;

      if(navigator.mediaDevices?.enumerateDevices){
        try{ await fillCameraList(); }catch(e){}
      }
    }catch(e){
      log(e);
      statusEl.textContent='Status: gagal memuat cascade (WASM).';
    }
  }

  // ===== Camera =====
  async function fillCameraList(){
    const devices = await navigator.mediaDevices.enumerateDevices();
    const cams = devices.filter(d=>d.kind==='videoinput');
    camSel.innerHTML='';
    cams.forEach((d,i)=>{
      const o=document.createElement('option');
      o.value=d.deviceId;
      o.textContent=d.label || `Kamera ${i+1}`;
      camSel.appendChild(o);
    });
  }

  function parseSize(v){
    const [w,h] = v.split('x').map(n=>parseInt(n,10));
    return {w,h};
  }

  function setCanvasSize(v){
    const {w,h} = parseSize(v);
    canvas.width=w;
    canvas.height=h;
  }

  async function startCamera(){
    const devId = camSel.value || undefined;
    const {w,h} = parseSize(sizeEl.value);
    const c = {
      video: devId
        ? {deviceId:{exact:devId}, width:{ideal:w}, height:{ideal:h}}
        : {width:{ideal:w}, height:{ideal:h}},
      audio:false
    };
    stream = await navigator.mediaDevices.getUserMedia(c);
    video.srcObject = stream;
    await video.play();

    await new Promise(res=>{
      const done=()=>res();
      if(video.readyState>=2 && video.videoWidth>0) return res();
      video.onloadedmetadata=done;
      video.onplaying=done;
      setTimeout(done,3000);
    });

    if(navigator.mediaDevices?.enumerateDevices){
      try{ await fillCameraList(); }catch(e){}
    }
  }

  function stopCamera(){
    if(stream){
      stream.getTracks().forEach(t=>t.stop());
      stream=null;
    }
    video.srcObject=null;
  }

  // ===== Stop saat VERIFIED =====
  function stopOnVerified(match){
    if(!running) return;
    running = false;
    if(rafId) cancelAnimationFrame(rafId);
    rafId = null;
    stopCamera();
    btnS.disabled = false;
    btnT.disabled = true;
    const msg = `VERIFIED (WASM): ${match.name} (score=${match.score.toFixed(4)}) — pemindaian dihentikan.`;
    console.log(msg);
    log(msg);
    statusEl.textContent = `Status: ${msg}`;
  }

  // ===== UI handlers =====
  btnS.onclick = async ()=>{
    if(!classifier){
      alert('OpenCV WebAssembly belum siap.');
      return;
    }
    detectEveryN = parseInt(nthEl.value,10) || 2;
    setCanvasSize(sizeEl.value);
    await startCamera();
    running=true;
    btnS.disabled=true;
    btnT.disabled=false;
    video.style.display = showVideoCb.checked ? 'block' : 'none';

    benchData.length = 0;
    updateBenchText();
    while(benchSvg.firstChild) benchSvg.removeChild(benchSvg.firstChild);

    startLoop();
    statusEl.textContent='Status: kamera aktif (WASM + benchmark)';
  };

  btnT.onclick = ()=>{
    running=false;
    if(rafId) cancelAnimationFrame(rafId);
    rafId=null;
    stopCamera();
    btnS.disabled=false;
    btnT.disabled=true;
    statusEl.textContent='Status: stopped';
  };

  showVideoCb.onchange = ()=>{
    video.style.display = showVideoCb.checked ? 'block' : 'none';
  };

  btnEnroll.onclick = ()=>{
    const nm = (nameEl.value||'').trim();
    if(!nm){
      alert('Isi nama.');
      return;
    }
    enrolling=true;
    enrollLeft = parseInt(samplesEl.value,10) || 20;
    enrollSum  = new Float32Array(256);
    statusEl.textContent=`Enroll "${nm}" — ambil ${enrollLeft} sampel (WASM)…`;
  };

  btnClear.onclick = ()=>{
    clearDB();
    alert('DB cleared (WASM).');
  };

  btnExport.onclick = ()=>{
    const blob=new Blob(
      [JSON.stringify(loadDB(),null,2)],
      {type:'application/json'}
    );
    const a=document.createElement('a');
    a.href=URL.createObjectURL(blob);
    a.download='face_db.json';
    a.click();
  };

  inImport.onchange = async e=>{
    const f=e.target.files[0];
    if(!f) return;
    const txt=await f.text();
    try{
      const obj=JSON.parse(txt);
      if(!obj || !Array.isArray(obj.labels)) throw 0;
      localStorage.setItem(DB_KEY, JSON.stringify(obj));
      alert('Import ok (WASM).');
    }catch{
      alert('File JSON tidak valid.');
    }
  };

  // ===== Main loop (detect+recognize+benchmark) =====
  function startLoop(){
    if(rgba){ rgba.delete(); rgba=null; }
    if(gray){ gray.delete(); gray=null; }

    rgba = new cv.Mat(canvas.height, canvas.width, cv.CV_8UC4);
    gray = new cv.Mat();
    const faces = new cv.RectVector();

    procFPS=0;
    lastFPS=performance.now();
    procCount=0;
    frameIndex=0;

    const step = ()=>{
      if(!running){
        if(rgba){ rgba.delete(); rgba=null; }
        if(gray){ gray.delete(); gray=null; }
        faces.delete();
        return;
      }

      if(video.readyState>=2 && video.videoWidth>0){
        try{
          ctx.drawImage(video,0,0,canvas.width,canvas.height);
          frameIndex++;

          if(frameIndex % detectEveryN === 0){
            const t0 = performance.now();

            const data = ctx.getImageData(0,0,canvas.width,canvas.height);
            rgba.data.set(data.data);
            cv.cvtColor(rgba, gray, cv.COLOR_RGBA2GRAY);
            cv.equalizeHist(gray, gray);

            classifier.detectMultiScale(
              gray, faces,
              1.1, 5, 0,
              new cv.Size(60,60)
            );
            facesCount = faces.size();

            let displayText='';

            if(faces.size()>0){
              let bi=0, ba=0;
              for(let i=0;i<faces.size();i++){
                const r=faces.get(i);
                const a=r.width*r.height;
                if(a>ba){ ba=a; bi=i; }
              }
              const r=faces.get(bi);

              let roi = gray.roi(r);
              let res = new cv.Mat();
              cv.resize(roi, res, new cv.Size(LBP_SIZE,LBP_SIZE), 0,0, cv.INTER_AREA);

              const desc = lbpHistFromBytes(res.data, res.cols, res.rows);

              if(enrolling){
                addInPlace(enrollSum, desc);
                enrollLeft--;
                statusEl.textContent=`Enroll "${nameEl.value.trim()}" — tersisa ${enrollLeft} (WASM)…`;

                if(enrollLeft<=0){
                  scaleInPlace(enrollSum, 1/parseInt(samplesEl.value,10));
                  const db = loadDB();
                  db.labels = db.labels.filter(x=>x.name===nameEl.value.trim()?false:true);
                  db.labels.push({name:nameEl.value.trim(), vec:Array.from(enrollSum)});
                  saveDB(db);
                  enrolling=false;
                  statusEl.textContent=`Enroll selesai untuk "${nameEl.value.trim()}" (WASM).`;
                }
              }else{
                const db   = loadDB();
                const match= bestMatch(desc, db);
                const thr  = parseFloat(thEl.value) || 0.9;

                if(match.score>=thr){
                  displayText = `${match.name} (${match.score.toFixed(2)})`;
                  stopOnVerified(match);
                }else{
                  displayText = `Unknown (${match.score.toFixed(2)})`;
                }
              }

              ctx.lineWidth = Math.max(2, Math.round(canvas.width/200));
              for(let i=0;i<faces.size();i++){
                const rr=faces.get(i);
                ctx.strokeStyle = i===bi ? '#00ff66' : '#66a3ff';
                ctx.strokeRect(rr.x, rr.y, rr.width, rr.height);
              }

              if(displayText){
                const rr=faces.get(bi);
                ctx.fillStyle='rgba(0,0,0,.5)';
                const w=ctx.measureText(displayText).width+14;
                ctx.fillRect(rr.x, rr.y-22, w, 20);
                ctx.fillStyle='#fff';
                ctx.fillText(displayText, rr.x+7, rr.y-7);
              }

              roi.delete();
              res.delete();
            }

            const t1 = performance.now();
            const dt = t1 - t0;
            benchAdd(dt);

            procCount++;
            const now=performance.now();
            if(now-lastFPS>1000){
              procFPS = procCount / ((now-lastFPS)/1000);
              procCount=0;
              lastFPS=now;
            }
          }
        }catch(e){
          log(e);
        }
      }

      drawHUD();
      schedule();
    };

    const schedule = ()=>{
      if("requestVideoFrameCallback" in HTMLVideoElement.prototype){
        video.requestVideoFrameCallback(()=>{ step(); });
      }else{
        rafId = requestAnimationFrame(step);
      }
    };
    schedule();
  }

  function drawHUD(){
    const pad=10, line=18;
    const t1=`FPS (processed): ${Math.round(procFPS)}`;
    const t2=`Faces: ${facesCount}`;
    const t3=enrolling ? `Enrolling: ${nameEl.value.trim()} (${enrollLeft} left)` : '';

    ctx.save();
    ctx.font='14px system-ui,Segoe UI,Roboto,Arial';

    const w=Math.max(
      ctx.measureText(t1).width,
      ctx.measureText(t2).width,
      ctx.measureText(t3).width
    ) + pad*2;
    const lines = enrolling ? 3 : 2;
    const h = lines*line + pad*2;

    ctx.fillStyle='rgba(0,0,0,.35)';
    ctx.fillRect(pad,pad,w,h);
    ctx.fillStyle='#e6eef6';
    ctx.fillText(t1, pad*2, pad+line);
    ctx.fillText(t2, pad*2, pad+line*2);
    if(enrolling) ctx.fillText(t3, pad*2, pad+line*3);
    ctx.restore();
  }

  if(navigator.mediaDevices?.enumerateDevices){
    fillCameraList().catch(()=>{});
  }
  </script>
</body>
</html>
